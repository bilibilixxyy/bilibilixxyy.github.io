---
layout: post
title: 542. 01 Matrix
---
### Question
Given a matrix consists of 0 and 1, find the distance of the nearest 0 for
each cell.

The distance between two adjacent cells is 1.



 **Example 1:**

    
    
     **Input:**
    [[0,0,0],
     [0,1,0],
     [0,0,0]]
    
    **Output:**
    [[0,0,0],
      [0,1,0],
     [0,0,0]]
    

**Example 2:**

    
    
    **Input:**
    [[0,0,0],
     [0,1,0],
     [1,1,1]]
    
    **Output:**
    [[0,0,0],
     [0,1,0],
     [1,2,1]]
    



 **Note:**

  1. The number of elements of the given matrix will not exceed 10,000.
  2. There are at least one 0 in the given matrix.
  3. The cells are adjacent in only four directions: up, down, left and right.

### Solution 1
General idea is `BFS`. Some small tricks:

  1. At beginning, set cell value to `Integer.MAX_VALUE` if it is not `0`.
  2. If newly calculated distance `>=` current distance, then we don't need to explore that cell again.

    
    
    public class Solution {
        public List<List<Integer>> updateMatrix(List<List<Integer>> matrix) {
            int m = matrix.size();
            int n = matrix.get(0).size();
            
            Queue<int[]> queue = new LinkedList<>();
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (matrix.get(i).get(j) == 0) {
                        queue.offer(new int[] {i, j});
                    }
                    else {
                        matrix.get(i).set(j, Integer.MAX_VALUE);
                    }
                }
            }
            
            int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
            
            while (!queue.isEmpty()) {
                int[] cell = queue.poll();
                for (int[] d : dirs) {
                    int r = cell[0] + d[0];
                    int c = cell[1] + d[1];
                    if (r < 0 || r >= m || c < 0 || c >= n || 
                        matrix.get(r).get(c) <= matrix.get(cell[0]).get(cell[1]) + 1) continue;
                    queue.add(new int[] {r, c});
                    matrix.get(r).set(c, matrix.get(cell[0]).get(cell[1]) + 1);
                }
            }
            
            return matrix;
        }
    }
    

LeetCode has changed the function signature. Updated code:

    
    
    public class Solution {
        public int[][] updateMatrix(int[][] matrix) {
            int m = matrix.length;
            int n = matrix[0].length;
            
            Queue<int[]> queue = new LinkedList<>();
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (matrix[i][j] == 0) {
                        queue.offer(new int[] {i, j});
                    }
                    else {
                        matrix[i][j] = Integer.MAX_VALUE;
                    }
                }
            }
            
            int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
            
            while (!queue.isEmpty()) {
                int[] cell = queue.poll();
                for (int[] d : dirs) {
                    int r = cell[0] + d[0];
                    int c = cell[1] + d[1];
                    if (r < 0 || r >= m || c < 0 || c >= n || 
                        matrix[r][c] <= matrix[cell[0]][cell[1]] + 1) continue;
                    queue.add(new int[] {r, c});
                    matrix[r][c] = matrix[cell[0]][cell[1]] + 1;
                }
            }
            
            return matrix;
        }
    }
    


### Solution 2
    
    
    def updateMatrix(self, matrix):
        answer = [[10000 * x for x in row] for row in matrix]
        for _ in range(4):
            for row in answer:
                for j in range(1, len(row)):
                    row[j] = min(row[j], row[j-1] + 1)
            answer = map(list, zip(*answer[::-1]))
        return answer
    

Based on @qswawrq's
[solution](https://discuss.leetcode.com/topic/83558/java-33ms-solution-with-
two-sweeps-in-o-n) which only considers down/right paths (meaning a
combination of only down and right moves, from some 0 to some 1) and up/left
paths. When I realized why that works, I realized that we don't even need
paths like `down,right,down,right`. We can instead go just
`down,down,right,right` or `right,right,down,down`. Just one turn (change of
direction). It's the same length, and all of the intermediate cells must be
`1` because otherwise `down,right,down,right` wouldn't have been an optimal
path in the first place.

So in my solution I simply **optimize in each direction, one after the
other**. For this I **"optimize rightwards"** and **"rotate the matrix by 90
degrees"** four times. Then I have covered every pair of directions, which is
enough to cover every straight path and every single-turn path.


### Solution 3
    
    
    public int[][] updateMatrix(int[][] matrix) {
         if (matrix.length == 0 || matrix[0].length == 0) {
            return matrix;
        }
        int[][] dis = new int[matrix.length][matrix[0].length];
        int range = matrix.length * matrix[0].length;
        
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == 0) {
                    dis[i][j] = 0;
                } else {
                    int upCell = (i > 0) ? dis[i - 1][j] : range;
                    int leftCell = (j > 0) ? dis[i][j - 1] : range;
                    dis[i][j] = Math.min(upCell, leftCell) + 1;
                }
            }
        }
        
        for (int i = matrix.length - 1; i >= 0; i--) {
            for (int j = matrix[0].length - 1; j >= 0; j--) {
                if (matrix[i][j] == 0) {
                    dis[i][j] = 0;
                } else {
                    int downCell = (i < matrix.length - 1) ? dis[i + 1][j] : range;
                    int rightCell = (j < matrix[0].length - 1) ? dis[i][j + 1] : range;
                    dis[i][j] = Math.min(Math.min(downCell, rightCell) + 1, dis[i][j]);
                }
            }
        }
        
        return dis;
    }



