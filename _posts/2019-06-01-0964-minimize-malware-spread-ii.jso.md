---
layout: post
title: 964. Minimize Malware Spread II
---
### Question
(This problem is the same as _Minimize Malware Spread_ , with the differences
bolded.)

In a network of nodes, each node `i` is directly connected to another node `j`
if and only if `graph[i][j] = 1`.

Some nodes `initial` are initially infected by malware.  Whenever two nodes
are directly connected and at least one of those two nodes is infected by
malware, both nodes will be infected by malware.  This spread of malware will
continue until no more nodes can be infected in this manner.

Suppose `M(initial)` is the final number of nodes infected with malware in the
entire network, after the spread of malware stops.

We will remove one node from the initial list, **completely removing it and
any connections from this node to any other node**.   Return the node that if
removed, would minimize `M(initial)`.  If multiple nodes could be removed to
minimize `M(initial)`, return such a node with the smallest index.



 **Example 1:**

    
    
     **Input:** graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
    **Output:** 0
    

**Example 2:**

    
    
    **Input:** graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
    **Output:** 1
    

**Example 3:**

    
    
    **Input:** graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
    **Output:** 1
    



 **Note:**

  1. `1 < graph.length = graph[0].length <= 300`
  2. `0 <= graph[i][j] == graph[j][i] <= 1`
  3. `graph[i][i] = 1`
  4. `1 <= initial.length < graph.length`
  5. `0 <= initial[i] < graph.length`

### Solution 1
you can get Chinese explanation in  
<https://buptwc.github.io/2018/10/21/Leetcode-928-Minimize-Malware-Spread-II/>

The idea of this question is similar to [leetcode 924 Minimize Malware
Spread](https://leetcode.com/problems/minimize-malware-
spread/discuss/181186/python-dfs-solution-with-picture-to-explain-my-
thought\(with-extra-Chinese-explanation\)).

The key point of these two questions is to analyze how to change a node from
an infected state to a safe one.

![image](https://assets.leetcode.com/users/2017111303/image_1540136419.png)  
as picture shows, the yellow node is the initial infected node.  
for the safe node [1,2,3,5,6], we analyze one by one.

we define `node a` are directly infected by `node b` if `node a` will be
infected by `node b` `without through any other infected node`.

For `node 1`, it will be directly infected by `node 0` and `node 4`,(0->1,
4->3->2->1)  
For `node 2`, it is same as `node 1`(0->1->2, 4->3->2)  
For `node 3`, it is same as `node 1`  
For `node 5`, it is same as `node 1`  
For `node 6`, it will be directly infected by `node 4`. (4 - > 6)

for node [1,2,3,5], even if we delete one node from the initial infected node,
it will be infected by another node in the end.

So, a node may be safe if and only if it's just `directly` infected by one
node. I called it `s_node`  
we can use bfs solution to find the all `s_node`, and store the only node that
can infect it.  
Finally, we count which node in the stored node appears the most.

    
    
    # 492ms
    import collections
    class Solution(object):
        def minMalwareSpread(self, graph, initial):
            n = len(graph)
            d = collections.defaultdict(list)
            for init in initial:
                vis = set(initial)
                Q = collections.deque([init])
                while Q:
                    infect = Q.popleft()
                    for node in range(len(graph[infect])):
                        if graph[infect][node] == 0: continue
                        if node in vis: continue
                        vis.add(node)
                        d[node].append(init)
                        Q.append(node)
            # count the most frequent node
            res = [0] * n
            for key in d:
                if len(d[key]) == 1:
                    res[d[key][0]] += 1
            if max(res) == 0: return min(initial)
            return res.index(max(res))
    


### Solution 2
Just count how many nodes can be saved by removing each of the candidates.
O(N^2)

Only one place needs attention is once we encounter a malware neighbor during
search, we will add current node to malware set as well.

Why? Because in order to make any node from "will be infected" to "won't be
infected" by removing one of the initial malwared nodes, one necessary
property for such a node is that **it cannot be conencted to more than 1
initial malwared nodes** **(notice "connected" means there is a path between
two nodes)** as in that case removing 1 node doesn't help, it will still be
infected from other direction (also obviously it has to be connected to at
least 1 initial malware node, which made it has to be connected to exactly 1
initial malwared node). Given that, we can conclude that in every search
branch in our DFS tree, if we encounter any malware neighbor along the search,
it means the node we are at right now (actually we can even say the whole
branch starting from the root) is not qualified as a "count" since it is
connected to more than 1 initial malwared node (as the root of DFS is always a
malware node since we start DFS from each initial malware node). So by knowing
that we can simply add node like this to malware set which can avoid repeated
visit and speed up!

![image](https://assets.leetcode.com/users/xxj79/image_1546028094.png)

In the above picture, A & D are initailly infected. B & C are both considered
"unqualified" here as either by removing A or D doesn't change B's or C's
final state as they will be infected from other direction anyways.

    
    
    class Solution {
        public int minMalwareSpread(int[][] graph, int[] initial) {
            Arrays.sort(initial);
            
            Set<Integer> mal = new HashSet<>();
            for(int n : initial)
                mal.add(n);
            
            int max = -1, ret = -1;
            for(int n : initial){
                int save = 0;
                Set<Integer> visited = new HashSet<>();
                visited.add(n);
                for(int i = 0; i<graph.length; i++){
                    if(i != n && graph[n][i] == 1){
                        int temp = dfs(i, visited, mal, graph);
                        if(temp < 0) continue; // encountered malware during exploration, meaning this whole branch doesn't count/contribute
                        save += temp;
                    }
                }
                if(save > max){ 
                    ret = n;
                    max = save;
                }
            }
            return ret;
        }
        
        private int dfs(int n, Set<Integer> visited, Set<Integer> mal, int[][] graph){
            if(visited.contains(n)) return 0;
            if(mal.contains(n)) return -1;
            visited.add(n);
            
            int ret = 1; // current node saved (at least for now)
            for(int i = 0; i<graph.length; i++){
                if(i != n && graph[n][i] == 1){
                    int temp = dfs(i, visited, mal, graph);
                    if(temp == -1) {
                        mal.add(n); // has neighbor malware, marked as malware as well
                        return -1; // return -1, indicating there's malware downstream in this branch, whole branch unqualified!
                    }
                    ret += temp;
                }
            }
            return ret;
        }
    }
    


### Solution 3
Idea is that, first, we disable all the nodes from initial list. And build the
union find set.

Then we try removing each node from the initial list in way of brute-force .  
Say in this trial, we will remove initial[i]. We execute the trial by marking
all the components linked by the elements from the init list except
initial[i]. Then we sum up the number of all the linked components at the end
of the trial, we compare the sum to a global_min. Hence we may find a node
that results in a minimum M(initial)

Note in my implementation of UFS, I use a parent array. In my array, if a node
is not root, then its value is its parent index, else if this is a root, its
value equals negative (number of this component). Hence we may mark the root
node and the parent relationship using only one value.

(Check this out if you don't know UFS:
[https://zh.wikipedia.org/wiki/并查集](https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86))

    
    
    class Solution {
        int[] parent;
        
        public int minMalwareSpread(int[][] graph, int[] initial) {
            int N = graph.length;
            parent = new int[N];
            Arrays.fill(parent, -1);
            Arrays.sort(initial);   // sort the initial list to get the min index of result in case of a tie
            Set<Integer> set = new HashSet<>();
            for (int n : initial) set.add(n);
            
            // build the union find set disabling the init elements
            for (int i = 0; i < N; i++) {
                if (set.contains(i)) continue;
                for (int j = 0; j < N; j++) {
                    if (set.contains(j)) continue;
                    if (graph[i][j] == 1) {
                        union(i, j);
                    }
                }
            }
            
            int total = Integer.MAX_VALUE;
            int res = -1;
            for (int skip = 0; skip < initial.length; skip++) {
                Map<Integer, Integer> cnts = new HashMap<>();
                for (int mal = 0; mal < initial.length; mal++) {
                    if (mal == skip) continue;
                    
                    int malId = initial[mal];
                    for (int i = 0; i < N; i++) {
                        if (i == initial[skip]) continue;
                        
                        if (graph[malId][i] == 1) {
                            int root = find(i);
                            cnts.putIfAbsent(root, -parent[root]);
                        }
                        
                    }
                    
                }
                
                int sum = 0;
                for (int v : cnts.values()) {
                    sum += v;
                }
                
                // if removing initial[skip] causes less spread
                if (sum < total) {
                    total = sum;
                    res = initial[skip];
                    
                }
            }
            
            return res;
        }
        
        private int find(int x) {
            if (parent[x] < 0) return x;
            parent[x] = find(parent[x]);
            return parent[x];
        }
        
        private void union(int x, int y) {
            x = find(x);
            y = find(y);
            if (x == y) return;
            if (parent[x] <= parent[y]) {
                parent[x] += parent[y];
                parent[y] = x;
            } else {
                parent[y] += parent[x];
                parent[x] = y;
            }
        }
    }
    



